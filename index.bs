<pre class="metadata">
Title: Loader
Group: WHATWG
H1: Loader
Shortname: loader
Repository: whatwg/loader
Inline Github Issues: true
Level: 1
Status: DREAM
ED: https://whatwg.github.io/loader
Editor: Eric Ferraiuolo, Yahoo https://yahoo.com, edf@ericf.me, https://github.com/ericf
Editor: Dave Herman, Mozilla https://mozilla.org, dherman@mozilla.com, http://calculist.org
Editor: Yehuda Katz, jQuery Foundation https://jquery.org, wycats@gmail.com, http://yehudakatz.com
Editor: Caridy Patiño, Yahoo https://yahoo.com, caridy@gmail.com, http://caridy.name
Abstract: This specification describes the behavior of loading JavaScript modules from a
Abstract: JavaScript host environment. It also provides APIs for intercepting the module
Abstract: loading process and customizing loading behavior.
Logo: https://resources.whatwg.org/logo-javascript.svg
!Version History: <a href="https://github.com/whatwg/loader/commits">https://github.com/whatwg/loader/commits</a>
!Participate: <a href="https://github.com/whatwg/loader/issues/new">File an issue</a> (<a href="https://github.com/whatwg/loader/issues?state=open">open issues</a>)

Opaque Elements: emu-alg, emu-note
</pre>

<style>
  .note + .example, .note + .note { margin-top: 1em; }

  emu-val { font-weight: bold; }
  emu-alg > ol, emu-alg > ol ol ol ol { list-style-type: decimal; }
  emu-alg > ol ol, emu-alg > ol ol ol ol ol { list-style-type: lower-alpha; }
  emu-alg > ol ol ol, emu-alg > ol ol ol ol ol ol { list-style-type: lower-roman; }
  emu-alg li { margin: 0; }
  emu-note { display: block; margin: 1em 0 1em 6em; color: #666; }
  emu-note::before { content: "Note"; text-transform: uppercase; margin-left: -6em; display: block; float: left; }
</style>
<script src="https://resources.whatwg.org/file-issue.js" async></script>

<h2 id="status" class="no-num no-toc">Status</h2>

This document is a work in progress and dreams of becoming a living standard.

<h2 id="module-loading">Module Loading</h2>

<p><i>This section is non-normative.</i></p>

<h3 id="intro">Introduction</h3>

Throughout their development, JavaScript modules have been divided into two general areas:

<ul>
<li>The <b>authoring format</b>, which defines the importing and exporting syntax, as well as the semantics for variable bindings and cycles.
<li>The <b>JavaScript Loader</b>, which provides a pipeline for on-demand, asynchronous loading of JavaScript modules.
</ul>

The authoring format was carefully designed to support pre-compilation (like Browserify) and on-demand asynchronous loading (like AMD). It defines the minimal syntax necessary to allow people to write portable modules that can work across different platforms, most notably Node.js and web browsers.

The JavaScript Loader allows host environments, like Node.js and browsers, to fetch and load modules on demand. It provides a hookable pipeline, to allow front-end packaging solutions like Browserify, WebPack and jspm to hook into the loading process.

This division provides a single format that developers can use in all JavaScript environments, and a separate loading mechanism for each environment. For example, a Node Loader would load its modules from the file system, using its own module lookup algorithm, while a Browser Loader would fetch modules and use browser-supplied packaging formats.

JavaScript itself, in ECMAScript 2015, defines the module syntax and the "linking semantics" between modules. When a module is requested, it delegates responsibility for loading the module to the host environment. The Loader defines how host environments can allow JavaScript code to configure that process.

The primary goal is to make as much of this process as possible consistent between Node and Browser environments. For example, if a JavaScript program wants to translate <code>.coffee</code> files to JavaScript on the fly, the Loader defines a "translate" hook that can be used. This allows programs to participate in the loading process, even though some details (specifically, the process of getting a particular module from its host-defined storage) will be different between environments.

<h3 id="pipeline">Loader Pipeline</h3>

<b>TODO:</b> include pipeline diagram

<h2 id="conventions">Conventions</h2>

<h3 id="well-known-symbols">Well-Known Symbols</h3>

Well-known symbols are built-in Symbol values that are explicitly referenced by algorithms of this specification. They are typically used as the keys of properties whose values serve as extension points of a specification algorithm.

Within this specification a well-known symbol is referred to by using a notation of the form @@<i>name</i>, where "<i>name</i>" is one of the values listed in table below:

<table>
  <thead>
    <tr>
      <th>Specification Name</th>
      <th>\[[Description]]</th>
      <th>Value and Purpose</th>
    </tr>
  </thead>
  <tr>
    <td>@@resolve</td>
    <td>"Reflect.Loader.resolve"</td>
    <td>A function valued property that is the resolve hook function of loader’s instances.</td>
  </tr>
  <tr>
    <td>@@fetch</td>
    <td>"Reflect.Loader.fetch"</td>
    <td>A function valued property that is the fetch hook function of loader’s instances.</td>
  </tr>
  <tr>
    <td>@@translate</td>
    <td>"Reflect.Loader.translate"</td>
    <td>A function valued property that is the translate hook function of loader’s instances.</td>
  </tr>
  <tr>
    <td>@@instantiate</td>
    <td>"Reflect.Loader.instantiate"</td>
    <td>A function valued property that is the instantiate hook function of loader’s instances.</td>
  </tr>
</table>

<h3 id="well-known-intrinsic-objects">Well-Known Intrinsic Objects</h3>

Well-known intrinsics are built-in objects that are explicitly referenced by the algorithms of this specification and which usually have Realm specific identities. Unless otherwise specified each intrinsic object actually corresponds to a set of similar objects, one per Realm.

Within this specification a reference such as %<i>name</i>% means the intrinsic object, associated with the current Realm, corresponding to the <i>name</i>. Determination of the current Realm and its intrinsics is described in ES2015, 8.3.

<h3 id="promises">Promises</h3>

This spec makes heavy use of promises, and adopts the notational conventions established in the promises guide.

<h4 id="reacting-to-promises">Reacting to Promises</h4>

<b><i>Transforming</i> p <i>with a new pass-through promise</i></b> is a shorthand for wrapping the promise to avoid exposing the original promise. It represents the following step:

<emu-alg>
1. Transforming _p_ with a fulfillment handler that, when called with argument _value_, returns _value_.
</emu-alg>

<h3 id="shorthand-phrases">Shorthand Phrases</h3>

<h4 id="reject-if-abrupt" aoid="RejectIfAbrupt">RejectIfAbrupt(x)</h4>

Algorithm steps that say

<emu-alg>
1. RejectIfAbrupt(_x_).
</emu-alg>

mean the same thing as:

<emu-alg>
1. If _x_ is an abrupt completion, then return a promise rejected with _x_.[[value]].
1. Else if _x_ is a Completion Record, then let _x_ be _x_.[[value]].
</emu-alg>

<h3 id="common-operations">Common Operations</h3>

<h4 id="create-object" aoid="CreateObject">CreateObject()</h4>

<emu-alg>
1. Let _obj_ be ObjectCreate(%ObjectPrototype%).
1. Return _obj_.
</emu-alg>

<h4 id="simple-define" aoid="SimpleDefine">SimpleDefine(obj, name, value)</h4>

<emu-alg>
1. Let _desc_ be a new PropertyDescriptor record {[[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true*}.
1. Return the result of calling OrdinaryDefineOwnProperty(_obj_, _name_, _desc_).
</emu-alg>

<h2 id="loader-objects">Loader Objects</h2>

<h3 id="loader-constructor">The Reflect.Loader Constructor</h3>

The Loader constructor is the initial value of the Loader property of the the Reflect object. When called as a constructor it creates and initializes a new Loader object. Reflect.Loader is not intended to be called as a function and will throw an exception when called in that manner.

The Reflect.Loader constructor is designed to be subclassable. It may be used as the value in an extends clause of a class definition. Subclass constructors that intend to inherit the specified Loader behaviour must include a super call to the Reflect.Loader constructor to create and initialize the subclass instance with the internal stage necessary to support the Reflect.Loader.prototype built-in methods.

<h4 id="new-reflect-loader">Reflect.Loader()</h4>

When Reflect.Loader is called with no arguments, the following steps are taken:

<emu-alg>
1. If NewTarget is *undefined*, then throw a *TypeError* exception.
1. Let _O_ be OrdinaryCreateFromConstructor(NewTarget, "Reflect.Loader.prototype").
1. ReturnIfAbrupt(_O_).
1. Let _registry_ to a new Registry(_O_).
1. Set _O_’s [[Registry]] internal slot to _registry_.
1. Return _O_.
</emu-alg>

<h3 id="properties-of-the-loader-constructor">Properties of the Reflect.Loader Constructor</h3>

The value of the \[[Prototype]] internal slot of the Reflect.Loader constructor is the intrinsic object %FunctionPrototype%.

Besides the internal slots and the length property (whose value is 0), the Reflect.Loader constructor has the following properties:

<h4 id="Reflect.Loader.prototype">Reflect.Loader.prototype</h4>

The value of Reflect.Loader.prototype is an ordinary object.

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: false }.

<h3 id="sec-properties-of-the-loader-prototype-object">Properties of the Reflect.Loader Prototype Object</h3>

<h4 id="Reflect.Loader.prototype.constructor">Reflect.Loader.prototype.constructor</h4>

The initial value of Reflect.Loader.prototype.constructor is Reflect.Loader.

<h4 id="reflect-loader-import">Reflect.Loader.prototype.import(name[, referrer])</h4>

The following steps are taken:

<emu-alg>
1. Let _loader_ be *this* value.
1. If Type(_loader_) is not Object, throw a *TypeError* exception.
1. If _loader_ does not have a [[Registry]] internal slot throw a *TypeError* exception.
1. Return the result of transforming Resolve(_loader_, _name_, _referrer_) with a fulfillment handler that, when called with argument _key_, runs the following steps:
  1. Return RequestReady(_loader_, _key_).
</emu-alg>

<h4 id="reflect-load-resolve">Reflect.Loader.prototype.resolve(name[, referrer])</h4>

The following steps are taken:

<emu-alg>
1. Let _loader_ be *this* value.
1. If Type(_loader_) is not Object, throw a *TypeError* exception.
1. Return Resolve(_loader_, _name_, _referrer_).
</emu-alg>

<h4 id="reflect-loader-load">Reflect.Loader.prototype.load(name[, referrer[, stage]])</h4>

The following steps are taken:

<emu-alg>
1. Let _loader_ be *this* value.
1. If Type(_loader_) is not Object, throw a *TypeError* exception.
1. If _stage_ is *undefined* then let _stage_ be "ready".
1. Return the result of transforming Resolve(_loader_, _name_, _referrer_) with a fulfillment handler that, when called with argument _key_, runs the following steps:
  1. If _stage_ is "fetch", then:
    1. Return the result of transforming RequestFetch(_loader_, _key_) with a new pass-through promise.
  1. If _stage_ is "translate", then:
    1. Return the result of transforming RequestTranslate(_loader_, _key_) with a new pass-through promise.
  1. If _stage_ is "instantiate", then:
    1. Return the result of transforming RequestInstantiateAll(_loader_, _key_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
      1. If _entry_.[[Module]] is a Function object, return _entry_.[[Module]].
      1. Return *undefined*.
  1. If _stage_ is "link", then:
    1. Return the result of transforming RequestLink(_loader_, _key_) with a fulfillment handler that returns *undefined*.
  1. If _stage_ is "ready", then:
    1. Return the result of transforming RequestReady(_loader_, _key_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
      1. Return GetModuleNamespace(_entry_.[[Module]]).
  1. Throw a new *TypeError*.
</emu-alg>

<h4 id="relect-loader-registry">get Reflect.Loader.prototype.registry</h4>

Reflect.Loader.prototype.registry is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps:

<emu-alg>
1. Let _loader_ be *this* value.
1. Return _loader_.[[Registry]].
</emu-alg>

<h4 id="relect-loader-@@tostringtag">Reflect.Loader.prototype [ @@toStringTag ]</h4>

The initial value of the @@toStringTag property is the String value "Object".

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: true }.

<h3 id="reflect-loader-internal-slots">Properties of Reflect.Loader Instances</h3>

Loader instances are ordinary objects that inherit properties from the *Reflect.Loader.prototype*.

Loader instances are initially created with the internal slots described in the following table:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Value Type (<em>non-normative</em>)</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[Realm]]</td>
    <td>Realm Record</td>
    <td>The realm this loader belongs to.</td>
  </tr>
  <tr>
    <td>\[[Registry]]</td>
    <td>An object</td>
    <td>An instance of Registry (<a href="#registry">4</a>).</td>
  </tr>
</table>

<h2 id="registry">Registry Objects</h2>

<h3 id="registry-abstract-operations">Abstract Operations for Registry Objects</h3>

<h4 id="registry-GetCurrentStage" aoid="GetCurrentStage">GetCurrentStage(entry)</h4>

The abstract operation GetCurrentStage with argument entry performs the following steps:

<emu-alg>
1. If Type(_entry_) is not Object, throw a *TypeError* exception.
1. Let _stages_ be _entry_.[[Pipeline]].
1. Return the first element of _stages_.
</emu-alg>

<h4 id="registry-GetStage" aoid="GetStage">GetStage(entry, stage)</h4>

The abstract operation GetStage with arguments entry and stage performs the following steps:

<emu-alg>
1. If Type(_entry_) is not Object, throw a *TypeError* exception.
1. Let _stages_ be _entry_.[[Pipeline]].
1. For each element _entry_ of _stages_, do
  1. If _entry_.[[Stage]] is equal to _stage_, then
    1. Return _entry_.
1. Return *undefined*.
</emu-alg>

<h4 id="registry-UpgradeToStage" aoid="UpgradeToStage">UpgradeToStage(entry, stage)</h4>

<emu-alg>
1. Let _pipeline_ be _entry_.[[Pipeline]].
1. Let _stageEntry_ be GetStage(_entry_, _stage_).
1. If _stageEntry_ is not *undefined*, then
  1. Repeat while the first element of _pipeline_ is not equal to _stageEntry_
    1. Remove first element from _pipeline_.
</emu-alg>

<emu-note>
  The internal slot [[Pipeline]] of an entry can never be empty.
</emu-note>

<emu-note>
  Alternative, this algo can be implemented using functional programming techinques or a reverse cycle to avoid walking the entries twice.
</emu-note>

An <dfn id="stage-entry">stage</dfn> is a record with the following fields:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Value Type (<em>non-normative</em>)</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[Stage]]</td>
    <td><code>"fetch"</code>, <code>"translate"</code>, <code>"instantiate"</code>, <code>"link"</code>, <code>"ready"</code></td>
    <td>A constant value to indicating which phase the entry is at.</td>
  </tr>
  <tr>
    <td>\[[Result]]</td>
    <td>Promise or <code>undefined</code></td>
    <td>A promise for the stage entry.</td>
  </tr>
</table>

<h4 id="registry-GetRegistryEntry" aoid="GetRegistryEntry">GetRegistryEntry(registry, key)</h4>

The abstract operation GetRegistryEntry with arguments registry and key performs the following steps:

<emu-alg>
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. Let _entries_ be _registry_.[[RegistryData]].
1. Let _pair_ be the entry in _entries_ such that _pair_.[[key]] is equal to _key_.
1. If _pair_ does not exist, then return *null*.
1. Let _entry_ be _pair_.[[value]].
1. Let _currentStage_ be GetCurrentStage(_entry_).
1. Let _result_ be the result of transforming _currentStage_.[[Result]] with a new pass-through promise.
1. Let _stage_ be _currentStage_.[[Stage]].
1. Let _result_ be CreateObject().
1. Call SimpleDefine(_result_, "stage", _stage_).
1. Call SimpleDefine(_result_, "result", _result_).
1. If _stage_ is "ready" then let _module_ be _entry_.[[Module]].
1. Else let _module_ be *undefined*.
1. Call SimpleDefine(_result_, "module", _module_).
1. If _entry_.[[Error]] is *nothing*, then:
  1. Call SimpleDefine(_result_, "error", *null*).
1. Else:
  1. Let _opt_ be CreateObject().
  1. Call SimpleDefine(_opt_, "value", _entry_.[[Error]]).
  1. Call SimpleDefine(_result_, "error", _opt_).
1. Return _result_.
</emu-alg>

A <dfn id="registry-entry">registry entry</dfn> is a record with the following fields:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Value Type (<em>non-normative</em>)</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[Key]]</td>
    <td>String</td>
    <td>The resolved module key.</td>
  </tr>
  <tr>
    <td>\[[Pipeline]]</td>
    <td>A List</td>
    <td>A list whose elements are stage records.</td>
  </tr>
  <tr>
    <td>\[[Metadata]]</td>
    <td>Object or <code>undefined</code></td>
    <td>The metadata object passed through the pipeline.</td>
  </tr>
  <tr>
    <td>\[[Dependencies]]</td>
    <td>List of pairs of String and (<a>registry entry</a> or <code>undefined</code>), or <code>undefined</code>.</td>
    <td>Table mapping unresolved names to their resolved modules.</td>
  </tr>
  <tr>
    <td>\[[Module]]</td>
    <td>Module Record or Function object or <code>undefined</code></td>
    <td>The Module Record if the entry is ready, or a thunk if the entry is delayed; otherwise <code>undefined</code>.</td>
  </tr>
  <tr>
    <td>\[[Error]]</td>
    <td>Any or <b>nothing</b></td>
    <td>An error that was encountered during one of the phases of the loading pipeline; <b>nothing</b> if no error has been encountered.</td>
  </tr>
</table>

<h3 id="registry-constructor">The Registry Constructor</h3>

The Registry constructor is the %Registry% intrinsic object. When called as a constructor it creates and initializes a new %Registry% object. %Registry% is not intended to be called as a function and will throw an exception when called in that manner.

<h4 id="new-registry" aoid="Registry">Registry(loader)</h4>

When Registry is called with argument <i>loader</i>, the following steps are taken:

<emu-alg>
1. If NewTarget is *undefined*, then throw a *TypeError* exception.
1. If Type(_loader_) is not Object, throw a *TypeError* exception.
1. Let _O_ be OrdinaryCreateFromConstructor(NewTarget, "%RegistryPrototype%", «[[RegistryData]]» ).
1. ReturnIfAbrupt(_O_).
1. Set _O_’s [[RegistryData]] internal slot to a new empty List.
1. Set _O_’s [[Loader]] internal slot to _loader_.
1. Return _O_.
</emu-alg>

<h3 id="properties-of-the-registry-constructor">Properties of the Registry Constructor</h3>

The value of the \[[Prototype]] internal slot of the Registry constructor is the intrinsic object %FunctionPrototype%.

Besides the internal slots and the length property (whose value is 0), the Registry constructor has the following properties:

<h4 id="registry-prototype">Registry.prototype</h4>

The value of Registry.prototype is %RegistryPrototype%.

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: false }.

<h3 id="registry-prototype-object">Properties of the Registry Prototype Object</h3>

<h4 id="registry-prototype-constructor">Registry.prototype.constructor</h4>

The initial value of Registry.prototype.constructor is %Registry%.

<h4 id="registry-prototype-@@iterator">Registry.prototype[ @@iterator ]()</h4>

When the @@iterator method is called it returns an Iterator object (ES2015 25.1.1.2) that iterates over the registry entries of the \[[RegistryData]] internal slot, returning each entry as a key value pair. The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. Let _entries_ be a new List.
1. For each _pair_ in _registry_.[[RegistryData]], do:
  1. Let _key_ be _pair_.[[key]].
  1. Let _entry_ be GetRegistryEntry(_registry_, _key_).
  1. Append { [[key]]: _key_, [[value]]: _entry_ } to _entries_.
1. Return CreateListIterator(_entries_).
</emu-alg>

The value of the name property of this function is "[Symbol.iterator]".

<h4 id="registry-prototype-lookup">Registry.prototype.lookup(key)</h4>

The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. Return GetRegistryEntry(_registry_, _key_).
</emu-alg>

<h4 id="registry-prototype-install">Registry.prototype.install(key, module)</h4>

The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. Let _entries_ be _registry_.[[RegistryData]].
1. Let _pair_ be the entry in _entries_ such that _pair_.[[key]] is equal to _key_.
1. If _pair_ exists, then throw a new *TypeError*.
1. Let _result_ be a new promise resolved with _module_.
1. Let _stageReadyEntry_ be a new stage entry record { [[Stage]]: "ready", [[Result]]: _result_ }.
1. Let _pipeline_ be a new List containing _stageReadyEntry_.
1. Let _entry_ be a new registry entry record { [[Key]]: _key_, [[Pipeline]]: _pipeline_, [[Metadata]]: *undefined*, [[Dependencies]]: *undefined*, [[Module]]: _module_ }.
1. Append { [[key]]: _key_, [[value]]: _entry_ } to _entries_.
</emu-alg>

<h4 id="registry-prototype-uninstall">Registry.prototype.uninstall(key)</h4>

The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. Let _entries_ be _registry_.[[RegistryData]].
1. Let _pair_ be the entry in _entries_ such that _pair_.[[key]] is equal to _key_.
1. If _pair_ does not exist, then throw a new *TypeError*.
1. Let _entry_ be _pair_.[[value]].
1. Let _stageEntry_ be GetCurrentStage(_entry_).
1. If _stageEntry_.[[Stage]] is not "link" or "ready", throw a new *TypeError*.
1. Remove _pair_ from _entries_.
</emu-alg>

<h4 id="registry-prototype-cancel">Registry.prototype.cancel(key)</h4>

The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. Let _entries_ be _registry_.[[RegistryData]].
1. Let _pair_ be the entry in _entries_ such that _pair_.[[key]] is equal to _key_.
1. If _pair_ does not exist, then throw a new *TypeError*.
1. Let _entry_ be _pair_.[[value]].
1. Let _stageEntry_ be GetCurrentStage(_entry_).
1. If _stageEntry_.[[Stage]] is "link" or "ready", throw a new *TypeError*.
1. Remove _pair_ from _entries_.
</emu-alg>

<h4 id="registry-prototype-provide">Registry.prototype.provide(key, stage, value)</h4>

The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. Let _loader_ be _registry_.[[Loader]] value.
1. Let _entry_ be EnsureRegistered(_loader_, _key_).
1. Let _stageEntry_ be GetStage(_entry_, _stage_).
1. If _stageEntry_ is *undefined*, throw a new *TypeError*.
1. If _stageEntry_.[[Result]] is *undefined*, then set _entry_.[[Result]] to a promise resolved with _value_.
1. Else, fulfill _entry_.[[Result]] with _value_.
1. UpgradeToStage(_entry_, _stage_).
</emu-alg>

<h4 id="registry-prototype-error">Registry.prototype.error(key, stage, value)</h4>

The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. Let _loader_ be _registry_.[[Loader]] value.
1. Let _entry_ be EnsureRegistered(_loader_, _key_).
1. Let _stageEntry_ be GetStage(_entry_, _stage_).
1. If _stageEntry_ is *undefined*, throw a new *TypeError*.
1. If _stageEntry_.[[Result]] is *undefined*, then set _entry_.[[Result]] to a promise rejected with _value_.
1. Else, reject _entry_.[[Result]] with _value_.
1. UpgradeToStage(_entry_, _stage_).
</emu-alg>

<h3 id="registry-internal-slots">Properties of Registry Instances</h3>

Registry instances are ordinary objects that inherit properties from the %RegistryPrototype%.

Registry instances are initially created with the internal slots described in the following table:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Value Type (<em>non-normative</em>)</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[RegistryData]]</td>
    <td>List of pairs of String and <a href="#registry-entry">registry entry</a>.</td>
    <td>The registry of installed modules.</td>
  </tr>
  <tr>
    <td>\[[Loader]]</td>
    <td>An object</td>
    <td>The loader this registry belongs to.</td>
  </tr>
</table>

<h2 id="pipeline-semantics">Loading Semantics</h2>

<h3 id="auxiliary-operations">Auxiliary Operations</h3>

<h4 id="ensure-registered" aoid="EnsureRegistered">EnsureRegistered(loader, key)</h4>

<emu-alg>
1. Assert: _loader_ has a [[Registry]] internal slot.
1. Let _pair_ be the entry in _loader_.[[Registry]] such that _pair_.[[key]] is equal to _key_.
1. If _pair_ exists, then:
  1. Let _entry_ be _pair_.[[value]].
1. Else:
  1. Let _pipeline_ be a new List.
  1. Add new stage entry record { [[Stage]]: "fetch", [[Result]]: undefined } as a new element of the list _pipeline_.
  1. Add new stage entry record { [[Stage]]: "translate", [[Result]]: undefined } as a new element of the list _pipeline_.
  1. Add new stage entry record { [[Stage]]: "instantiate", [[Result]]: undefined } as a new element of the list _pipeline_.
  1. Add new stage entry record { [[Stage]]: "link", [[Result]]: undefined } as a new element of the list _pipeline_.
  1. Add new stage entry record { [[Stage]]: "ready", [[Result]]: undefined } as a new element of the list _pipeline_.
  1. Let _entry_ be a new registry entry record { [[Key]]: _key_, [[Pipeline]]: _pipeline_, [[Metadata]]: *undefined*, [[Dependencies]]: *undefined*, [[Module]]: *undefined*, [[Error]]: *nothing* }.
  1. Append { [[key]]: _key_, [[value]]: _entry_ } to _loader_.[[Registry]].
1. Return _entry_.
</emu-alg>

<h4 id="resolve" aoid="Resolve">Resolve(loader, name, referrer)</h4>

<emu-alg>
1. Let _hook_ be GetMethod(_loader_, @@resolve).
1. Return the result of promise-calling _hook_(_name_, _referrer_).
</emu-alg>

<h4 id="extract-dependencies" aoid="ExtractDependencies">ExtractDependencies(loader, entry, optionalInstance, source)</h4>

<emu-alg>
1. Let _instance_ be Instantiation(_loader_, _optionalInstance_, _source_).
1. ReturnIfAbrupt(_instance_).
1. // TODO: edge case: what if _instance_ is a thenable function?
1. Fulfill _entry_.[[Instantiate]] with _instance_.
1. Let _deps_ be a new empty List.
1. If _instance_ is a Module Record, then:
  1. Assert: _instance_ is a Source Text Module Record.
  1. Set _instance_.[[RegistryEntry]] to _entry_.
  1. For each _dep_ in _instance_.[[RequestedModules]], do:
    1. Append the record { [[key]]: _dep_, [[value]]: *undefined* } to _deps_.
1. Set _entry_.[[Dependencies]] to _deps_.
1. Set _entry_.[[Module]] to _instance_.
1. UpgradeToStage(_entry_, "link").
</emu-alg>

<h4 id="instantiation" aoid="Instantiation">Instantiation(loader, result, source)</h4>

<emu-alg>
1. If _result_ is *undefined*, then return ParseModule(_source_).
1. If IsCallable(_result_) is *false* then throw a new *TypeError*.
1. Set _result_.[[Realm]] to _loader_.[[Realm]].
1. Return _result_.
</emu-alg>

<h3 id="loading-operations">Loading Operations</h3>

<h4 id="request-fetch" aoid="RequestFetch">RequestFetch(loader, key)</h4>

<emu-alg>
1. Let _entry_ be EnsureRegistered(_loader_, _key_).
1. Let _fetchStageEntry_ be GetStage(_entry_, "fetch").
1. If _fetchStageEntry_ is *undefined*, return a promise resolved with *undefined*.
1. Let _hook_ be GetMethod(_loader_, @@fetch).
1. // TODO: metadata object
1. Let _p0_ be the result of promise-calling _hook_(_key_).
1. Let _p1_ be the result of transforming _p0_ with a new pass-through promise.
1. Let _p2_ be the result of transforming _p1_ with a fulfillment handler that, when called with argument _payload_, runs the following steps:
  1. UpgradeToStage(_entry_, "translate").
  1. Return _payload_.
1. Set _fetchStageEntry_.[[Result]] to _p1_.
1. Return _p1_.
</emu-alg>

<h4 id="request-translate" aoid="RequestTranslate">RequestTranslate(loader, key)</h4>

<emu-alg>
1. Let _entry_ be EnsureRegistered(_loader_, _key_).
1. Let _translateStageEntry_ be GetStage(_entry_, "translate").
1. If _translateStageEntry_ is *undefined*, return a promise resolved with *undefined*.
1. Let _hook_ be GetMethod(_loader_, @@translate).
1. Let _p_ be the result of transforming RequestFetch(_loader_, _key_) with a fulfillment handler that, when called with argument _payload_, runs the following steps:
  1. // TODO: metadata
  1. Let _p0_ be the result of promise-calling _hook_(_key_, _payload_).
  1. Let _p1_ be the result of transforming _p0_ with a new pass-through promise.
  1. Let _p2_ be the result of transforming _p1_ with a fulfillment handler that, when called with argument _source_, runs the following steps:
    1. UpgradeToStage(_entry_, "instantiate").
    1. Return _source_.
  1. Return _p1_.
1. Set _translateStageEntry_.[[Result]] to _p_.
1. Return _p_.
</emu-alg>

<h4 id="request-instantiate" aoid="RequestInstantiate">RequestInstantiate(loader, key)</h4>

<emu-alg>
1. Let _entry_ be EnsureRegistered(_loader_, _key_).
1. Let _instantiateStageEntry_ be GetStage(_entry_, "instantiate").
1. If _instantiateStageEntry_ is *undefined*, return a promise resolved with *undefined*.
1. Let _hook_ be GetMethod(_loader_, @@instantiate).
1. Let _p_ be the result of transforming RequestTranslate(_loader_, _key_) with a fulfillment handler that, when called with argument _source_, runs the following steps:
  1. // TODO: metadata
  1. Let _p0_ be the result of promise-calling _hook_(_key_, _source_).
  1. Let _p1_ be the result of transforming _p0_ with a new pass-through promise.
  1. Let _p2_ be the result of transforming _p1_ with a fulfillment handler that, when called with argument _optionalInstance_, runs the following steps:
    1. Let _status_ be ExtractDependencies(_loader_, _entry_, _optionalInstance_, _source_).
    1. ReturnIfAbrupt(_status_).
    1. Return _entry_.
  1. Return _p1_.
1. Set _instantiateStageEntry_.[[Result]] to _p_.
1. Return _p_.
</emu-alg>

<h4 id="request-instantiate-all" aoid="RequestInstantiateAll">RequestInstantiateAll(loader, key)</h4>

<emu-alg>
1. Return the result of transforming RequestInstantiate(_loader_, _key_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
  1. Let _depLoads_ be a new empty List.
  1. For each _pair_ in _entry_.[[Dependencies]], do:
    1. Let _p_ be the result of transforming Resolve(_loader_, _pair_.[[key]], _key_) with a fulfillment handler that, when called with value _depKey_, runs the following steps:
      1. Let _depEntry_ be EnsureRegistered(_loader_, _depKey_).
      1. Let _currentStageEntry_ be GetCurrentStage(_entry_).
      1. If _currentStageEntry_.[[Stage]] is "ready", then:
        1. Let _dep_ be _depEntry_.[[Module]].
        1. Set _pair_.[[value]] to _dep_.
        1. Return _dep_.
      1. Return the result of transforming RequestInstantiateAll(_loader_, _depKey_) with a fulfillment handler that, when called with value _depEntry_, runs the following steps:
        1. Let _dep_ be _depEntry_.[[Module]].
        1. Set _pair_.[[value]] to _dep_.
        1. Return _dep_.
    1. Append _p_ to _depLoads_.
  1. Let _p_ be the result of waiting for all _depLoads_.
  1. Return the result of transforming _p_ with a fulfillment handler that, when called, runs the following steps:
    1. Return _entry_.
</emu-alg>

<h4 id="request-link" aoid="RequestLink">RequestLink(loader, key)</h4>

<emu-alg>
1. Let _entry_ be EnsureRegistered(_loader_, _key_).
1. Let _linkStageEntry_ be GetStage(_entry_, "link").
1. If _linkStageEntry_ is *undefined*, return a promise resolved with *undefined*.
1. Return the result of transforming RequestInstantiateAll(_loader_, _key_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
  1. Assert: _entry_'s whole dependency graph is in "link" stage.
  1. Let _status_ be Link(_loader_, _entry_).
  1. ReturnIfAbrupt(_status_).
  1. Assert: _entry_'s whole dependency graph is in "ready" stage.
  1. Return _entry_.
</emu-alg>

<h4 id="request-ready" aoid="RequestReady">RequestReady(loader, key)</h4>

<emu-alg>
1. Let _entry_ be EnsureRegistered(_loader_, _key_).
1. Let _currentStageEntry_ be GetCurrentStage(_entry_).
1. If _currentStageEntry_.[[Stage]] is equal "ready", return _currentStageEntry_.[[Result]].
1. Return the result of transforming RequestLink(_loader_, _key_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
  1. Let _module_ be _entry_.[[Module]].
  1. Let _status_ be the result of calling the ModuleEvaluation abstract operation of _module_ with no arguments.
  1. ReturnIfAbrupt(_status_).
  1. Return _module_.
</emu-alg>


<h2 id="linking-semantics">Linking Semantics</h2>

<h3 id="resolving-dependencies">Resolving Dependencies</h3>

<h4 id="host-resolve-imported-module" aoid="HostResolveImportedModule">HostResolveImportedModule(module, requestName)</h4>

The modules spec should only invoke this operation from methods of Source Text Module Records, and this spec does not invoke the operation at all.

<emu-alg>
1. Assert: _module_ is a Source Text Module Record.
1. Let _entry_ be _module_.[[RegistryEntry]].
1. Let _currentStageEntry_ be GetCurrentStage(_entry_).
1. Assert: _currentStageEntry_.[[Stage]] is in "link" or "ready" stage.
1. Let _pair_ be the pair in _entry_.[[Dependencies]] such that _pair_.[[key]] is equal to _requestName_.
1. Assert: _pair_ is defined.
1. Let _dep_ be _pair_.[[value]].
1. Let _depStageEntry_ be GetCurrentStage(_dep_).
1. Assert: _depStageEntry_.[[Stage]] is equal "link" or "ready" stage.
1. Return _dep_.[[Module]].
</emu-alg>

<h3 id="linking">Linking</h3>

<h4 id="link" aoid="Link">Link(loader, root)</h4>

<emu-alg>
1. Assert: _root_ is a registry entry record in "link" stage.
1. Let _deps_ be DependencyGraph(_root_).
1. For each _dep_ in _deps_, do:
  1. Let _depStageEntry_ be GetCurrentStage(_dep_).
  1. If _depStageEntry_.[[Stage]] is "link" and _dep_.[[Module]] is a Function object, then:
    1. Let _f_ be _dep_.[[Module]].
    1. Let _m_ be _f_().
    1. ReturnIfAbrupt(_m_).
    1. Set _dep_.[[Module]] to _m_.
    1. UpgradeToStage(_dep_, "ready").
1. Assert: the following sequence is guaranteed not to run any user code.
1. For each _dep_ in _deps_, do:
  1. Let _depStageEntry_ be GetCurrentStage(_dep_).
  1. If _depStageEntry_.[[Stage]] is "link", then:
    1. Let _module_ be _dep_.[[Module]].
    1. Assert: _module_ is a Module Record.
    1. Let _status_ be the result of calling the ModuleDeclarationInstantiation abstract operation of _module_ with no arguments.
    1. ReturnIfAbrupt(_status_).
    1. UpgradeToStage(_dep_, "ready").
1. Return *undefined*.
</emu-alg>

<h4 id="dependency-graph" aoid="DependencyGraph">DependencyGraph(root)</h4>

<emu-alg>
1. Let _result_ be a new empty List.
1. Call ComputeDependencyGraph(_root_, _result_).
1. Return _result_.
</emu-alg>

<h4 id="compute-dependency-graph" aoid="ComputeDependencyGraph">ComputeDependencyGraph(entry, result)</h4>

<emu-alg>
1. If _entry_ is already in _result_, then return *undefined*.
1. Append _entry_ to _result_.
1. For each _pair_ in _entry_.[[Dependencies]], do:
  1. Assert: _pair_.[[value]] is defined.
  1. Call ComputeDependencyGraph(_pair_.[[value]], _result_).
1. Return *undefined*.
</emu-alg>

<h2 id="module-objects">Module Objects</h2>

<h3 id="reflective-module-record">Reflective Module Records</h3>

A <dfn>reflective module record</dfn> is a kind of module record. It extends

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Value Type (<em>non-normative</em>)</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[LocalExports]]</td>
    <td>A List of Strings</td>
    <td>The set of exported names stored in this module's environment.</td>
  </tr>
  <tr>
    <td>\[[IndirectExports]]</td>
    <td>A List of pairs of String and {\[[module]]: Module Record, \[[bindingName]]: String}.</td>
    <td>The set of re-exported bindings. This ensures that ResolveExport can fully resolve re-exports.</td>
  </tr>
  <tr>
    <td>\[[Evaluate]]</td>
    <td>A function object or <code>undefined</code></td>
    <td>A thunk to call when the the module is evaluated, or <code>undefined</code> if the module is already evaluated.</td>
  </tr>
</table>

-<h3 id="module-abstract-operations">Abstract Operations for Module Objects</h3>

<h4 id="parse-exports-descriptors" aoid="ParseExportsDescriptors">ParseExportsDescriptors(obj)</h4>

<b>TODO:</b> parse as in <a href="https://gist.github.com/dherman/fbf3077a2781df74b6d8">these examples</a>
<ul>
  <li>uninitialized, mutable: <code>{ }</code>
  <li>uninitialized, immutable: <code>{ const: true }</code>
  <li>initialized, mutable: <code>{ value: 42 }</code>
  <li>initialized, immutable: <code>{ value: 42, const: true }</code>
  <li>re-export (immutable): <code>{ module: m, import: "foo" }</code>
</ul>

<emu-alg>
1. // TODO: spec me
</emu-alg>

<h4 id="create-module-mutator" aoid="CreateModuleMutator">CreateModuleMutator(module)</h4>

<emu-alg>
1. // TODO: spec me
</emu-alg>


<h4 id="get-export-names" aoid="GetExportNames">GetExportNames(exportStarStack)</h4>

The following steps are taken:

<emu-alg>
1. Let _module_ be this Reflective Module Record.
1. Let _exports_ be a new empty List.
1. For each _name_ in _module_.[[LocalExports]], do:
  1. Append _name_ to _exports_.
1. For each _pair_ in _module_.[[IndirectExports]], do:
  1. Append _pair_.[[key]] to _exports_.
1. Return _exports_.
</emu-alg>

<h4 id="resolve-export" aoid="ResolveExport">ResolveExport(exportName, resolveStack, exportStarStack)</h4>

<emu-alg>
1. Let _module_ be this Reflective Module Record.
1. If _resolveStack_ contains a record _r_ such that _r_.[[module]] is equal to _module_ and _r_.[[exportName]] is equal to _exportName_, then
  1. Assert: this is a circular import request.
  1. Throw a SyntaxError exception.
1. Append the record {[[module]]: _module_, [[exportName]]: _exportName_} to _resolveStack_.
1. Let _exports_ be _module_.[[LocalExports]].
1. Let _pair_ be the pair in _exports_ such that _pair_.[[key]] is equal to _exportName_.
1. If _pair_ is defined, then:
  1. Return the Record { [[module]]: _module_, [[bindingName]]: _exportName_ }.
1. Let _exports_ be _module_.[[IndirectExports]].
1. Let _pair_ be the pair in _exports_ such that _pair_.[[key]] is equal to _exportName_.
1. If _pair_ is defined, then return _pair_.[[value]].
1. Return *null*.
</emu-alg>

<h4 id="module-declaration-instantiation" aoid="ModuleDeclarationInstantiation">ModuleDeclarationInstantiation()</h4>

Reflective modules are always already instantiated.

<emu-alg>
1. Return *undefined*.
</emu-alg>

<h4 id="module-evaluation" aoid="ModuleEvaluation">ModuleEvaluation()</h4>

<emu-alg>
1. Let _module_ be this Reflective Module Record.
1. Let _evaluate_ be _module_.[[Evaluate]].
1. Set _module_.[[Evaluate]] to *undefined*.
1. Return _evaluate_().
</emu-alg>

<h3 id="module-constructor">The Reflect.Module Constructor</h3>

The Module constructor is the initial value of the Module property of the the Reflect object. When called as a constructor it creates and initializes a new Module object. Reflect.Module is not intended to be called as a function and will throw an exception when called in that manner.

The Reflect.Module constructor is designed to be subclassable. It may be used as the value in an extends clause of a class definition. Subclass constructors that intend to inherit the specified Module behaviour must include a super call to the Reflect.Module constructor to create and initialize the subclass instance with the internal stage necessary to integrated with loaders.

<h4 id="new-reflect-module">Reflect.Module(descriptors[, executor[, evaluate]])</h4>

When Reflect.Module is called with arguments <i>descriptors</i>, <i>executor</i>, and <i>evaluate</i>, the following steps are taken:

<emu-alg>
1. Let _realm_ be the current Realm.
1. Let _env_ be NewModuleEnvironment(_realm_.[[globalEnv]]).
1. Let _exportDescriptors_ be ParseExportsDescriptors(_descriptors_). // TODO: interleave the subsequent loop with parsing?
1. Let _localExports_ be a new empty List.
1. Let _indirectExports_ be a new empty List.
1. Let _exportNames_ be a new empty List.
1. Let _envRec_ be _env_'s environment record.
1. For each _desc_ in _exportDescriptors_, do:
  1. Let _exportName_ be _desc_.[[Name]].
  1. Append _exportName_ to _exportNames_.
  1. If _desc_ is an Indirect Export Descriptor, then:
    1. Let _otherMod_ be _desc_.[[Module]].
    1. Let _resolution_ be _otherMod_.ResolveExport(_desc_.[[Import]], « »).
    1. ReturnIfAbrupt(_resolution_).
    1. If _resolution_ is *null*, then throw a SyntaxError exception.
    1. Append the record {[[key]]: _exportName_, [[value]]: _resolution_} to _indirectExports_.
  1. Else:
    1. Append _exportName_ to _localExports_.
    1. If _desc_ is an Immutable Export Descriptor, then:
      1. Let _status_ be _envRec_.CreateImmutableBinding(_exportName_, *true*).
      1. Assert: _status_ is not an abrupt completion.
    1. Else:
      1. Assert: _desc_ is a Mutable Export Descriptor.
      1. Let _status_ be _envRec_.CreateMutableBinding(_exportName_, *false*).
      1. Assert: _status_ is not an abrupt completion.
    1. If _desc_.[[Initialized]] is *true*, then:
      1. Call _envRec_.InitializeBinding(_exportName_, _desc_.[[Value]]).
1. If _evaluate_ is *undefined*, then let _evaluated_ be *true*. Otherwise let _evaluated_ be *false*.
1. Let _mod_ be a new Reflective Module Record {[[Realm]]: _realm_, [[Environment]]: _env_, [[Namespace]]: *undefined*, [[Evaluated]]: _evaluated_, [[LocalExports]]: _localExports_, [[IndirectExports]]: _indirectExports_, [[Evaluate]]: _evaluate_}.
1. Let _ns_ be ModuleNamespaceCreate(_mod_, _realm_, _exportNames_).
1. Set _mod_.[[Namespace]] to _ns_.
1. If _executor_ is not *undefined*, then
  1. Let _mutator_ be CreateModuleMutator(_mod_).
  1. Let _status_ be _executor_(_mutator_, _ns_).
  1. ReturnIfAbrupt(_status_).
1. Return _ns_.
</emu-alg>

<h3 id="properties-of-the-module-constructor">Properties of the Reflect.Module Constructor</h3>

The value of the \[[Prototype]] internal slot of the Reflect.Module constructor is the intrinsic object %FunctionPrototype%.

Besides the internal slots and the length property (whose value is 0), the Reflect.Loader constructor has the following properties:

<h4 id="Reflect.Module.evaluate">Reflect.Module.evaluate(m)</h4>

<b>TODO:</b> way to force evaluation of a module namespace exotic object (<code>Reflect.Module.evaluate(m)</code>? <code>m[Reflect.Module.evaluate]()</code>?)

<h4 id="Reflect.Module.prototype">Reflect.Module.prototype</h4>

The value of Reflect.Module.prototype is an ordinary object with a null \[[Prototype]].

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: false }.

<h3 id="reflect-module-internal-slots">Properties of Module Instances</h3>

Reflect.Module instances are module namespace exotic objects.

<h2 id="local">Local Loading</h2>

<b>TODO:</b>

<ul>
<li>syntax for accessing module local information: <code>import local from this;</code>
<li>dynamic import: <code>local.import()</code>
<li>extending the hooks to handle <code>this</code>
<li>debugging info
<li>room for host environment-specific data
</ul>


<h2 id="browser">Browser Loader</h2>

Every host environment must implement a default loader object as the initial value of the loader property of the System object.

<h3 id="system-loader-instance">System.loader Object</h3>

The Default Browser Loader Object is an %BrowserLoader% instance, whose internal slots are set as if it had been constructed by the expression Construct(%BrowserLoader%).

<h2 id="browser-loader">BrowserLoader Objects</h2>

<h3 id="browser-loader-constructor">The BrowserLoader Constructor</h3>

The BrowserLoader constructor is the %BrowserLoader% intrinsic object. When called as a constructor it creates and initializes a new %BrowserLoader% object. %BrowserLoader% is not intended to be called as a function and will throw an exception when called in that manner.

<h3 id="properties-of-the-browser-loader-constructor">Properties of the BrowserLoader Constructor</h3>

The value of the \[[Prototype]] internal slot of the BrowserLoader constructor is the intrinsic object %FunctionPrototype%.

Besides the internal slots and the length property (whose value is 0), the BrowserLoader constructor has the following properties:

<h4 id="browser-loader-prototype">BrowserLoader.prototype</h4>

The value of BrowserLoader.prototype is %BrowserLoaderPrototype%.

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: false }.

<h3 id="properties-of-the-browser-loader-prototype">Properties of the BrowserLoader Prototype</h3>

<h4 id="browser-loader-prototype-@@resolve">BrowserLoader.prototype[ @@resolve ](name, referrer)</h4>

When the @@resolve method is called, the following steps are taken:

<b>TODO:</b> name resolution policy
<ul>
  <li>relative and site-relative URLs: <code>"./utils.js"</code>, <code>"/scripts/utils.js"</code>
  <li>JS standard modules: <code>"std/math"</code>, <code>"std/json"</code>, <code>"std/reflect"</code>
  <li>Web standard modules: <code>"web/worker"</code>, <code>"web/audio"</code>
  <li>absolute URLs: <code>"https://cdn.example.com/jquery/v/2.0"</code>
</ul>

The value of the name property of this function is "[Reflect.Loader.resolve]".

<h4 id="browser-loader-prototype-@@fetch">BrowserLoader.prototype[ @@fetch ](key)</h4>

When the @@fetch method is called, the following steps are taken:

<b>TODO:</b>
<ul>
  <li>reference fetch standard
  <li>cross-origin produces an opaque object as in ServiceWorker
  <li>CORS, CSP
  <li>other kinds of web assets
</ul>

The value of the name property of this function is "[Reflect.Loader.fetch]".

<h4 id="browser-loader-prototype-@@translate">BrowserLoader.prototype[ @@translate ](key, payload)</h4>

When the @@translate method is called, the following steps are taken:

<b>TODO:</b> no-op.

The value of the name property of this function is "[Reflect.Loader.translate]".

<h4 id="browser-loader-prototype-@@instantiate">BrowserLoader.prototype[ @@instantiate ](key, source)</h4>

When the @@instantiate method is called, the following steps are taken:

<b>TODO:</b>
<ul>
  <li>basically a no-op.
  <li>but also needs to re-absorb opaque responses.
</ul>

The value of the name property of this function is "[Reflect.Loader.instantiate]".

<h2 id="annexes" class="no-num">Annexes</h2>

<h3 id="list-of-well-known-intrinsic-objects">List of Well-Known Intrinsic Objects</h3>

The intrinsics are listed in table below:

<table>
  <thead>
    <tr>
      <th>Intrinsic Name</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>%BrowserLoader%</td>
    <td>The browser loader constructor (<a href="#browser-loader-constructor">10.1</a>)</td>
  </tr>
  <tr>
    <td>%BrowserLoaderPrototype%</td>
    <td>The initial value of the *prototype* data property of %BrowserLoader% (<a href="#browser-loader-prototype">10.2.1</a>)</td>
  </tr>
  <tr>
    <td>%Registry%</td>
    <td>The registry constructor (<a href="#registry-constructor">4.1</a>)</td>
  </tr>
  <tr>
    <td>%RegistryPrototype%</td>
    <td>The initial value of the *prototype* data property of %Registry% (<a href="#registry-prototype">4.3.1</a>)</td>
  </tr>
</table>
